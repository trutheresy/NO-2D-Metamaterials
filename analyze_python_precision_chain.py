#!/usr/bin/env python3
"""
Analyze the precision (dtype) chain in Python K and M matrix computation.
"""

import numpy as np

print("=" * 80)
print("Python K and M Matrix Computation Precision Chain")
print("=" * 80)

print("\n1. Material Property Extraction (system_matrices_vec.py lines 50-58):")
print("   - design_expanded: Input dtype (typically float64 from steel-rubber paradigm)")
print("   - design_ch0, design_ch1, design_ch2: float64 (intermediate calculation)")
print("     → Comment: 'Use float64 for intermediate calculation to avoid overflow'")
print("   - E, nu, rho: float32 (after .astype(np.float32))")
print("   - t: Input dtype (typically float64 or float32)")
print()
print("   Code:")
print("     design_ch0 = design_expanded[:, :, 0].astype(np.float64)  # float64")
print("     E = (...).T.astype(np.float32)  # float32")

print("\n2. Element Stiffness Matrix (elements_vec.py):")
print("   - Input E, nu, t: float32")
print("   - k_ele: Preallocated as float32")
print("     → Code: k_ele = np.zeros((n_elements, 8, 8), dtype=np.float32)")
print("   - coeff: Computed from float32 inputs, then cast to float32")
print("     → Code: coeff = ((1/48) * E * t / (1 - nu**2)).astype(np.float32)")
print("   - Template values: Computed with float32 operations")
print("     → Example: k_ele[:, 0, 0] = 24 - 8*nu  (all float32)")
print("   - Output: AllLEle (n_elements, 8, 8) as float32")

print("\n3. Element Mass Matrix (elements_vec.py):")
print("   - Input rho, t: float32")
print("   - m_ele: Preallocated as float32")
print("     → Code: m_ele = np.zeros((n_elements, 8, 8), dtype=np.float32)")
print("   - Template values: Computed with float32 operations")
print("   - Output: AllLMat (n_elements, 8, 8) as float32")

print("\n4. Matrix Assembly (system_matrices_vec.py lines 108-134):")
print("   - AllLEle_2d: Reshaped from float32 element matrices → float32")
print("   - AllLEle_transposed: Transposed float32 → float32")
print("   - value_K: Flattened and cast to float32")
print("     → Code: value_K = AllLEle_transposed.flatten(order='F').astype(np.float32)")
print("   - value_M: Flattened and cast to float32")
print("     → Code: value_M = AllLMat_transposed.flatten(order='F').astype(np.float32)")
print("   - Final K, M sparse matrices: float32")
print("     → Code: K = coo_matrix(..., dtype=np.float32)")
print("     → Code: M = coo_matrix(..., dtype=np.float32)")

print("\n" + "=" * 80)
print("Summary: Precision Chain")
print("=" * 80)
print("\nStep 1: Material Properties")
print("  Input (design):           float64 (from steel-rubber paradigm)")
print("  Intermediate calculation: float64 (to avoid overflow)")
print("  Material properties:      float32 (E, nu, rho)")
print()
print("Step 2: Element Matrices")
print("  Input (E, nu, t, rho):    float32")
print("  Element computations:     float32")
print("  Output (AllLEle, AllLMat): float32")
print()
print("Step 3: Matrix Assembly")
print("  Input (element matrices): float32")
print("  Assembly operations:      float32")
print("  Final matrices (K, M):    float32")
print()
print("=" * 80)
print("Key Points:")
print("=" * 80)
print("1. Material property extraction uses float64 for intermediate calculations")
print("   to avoid overflow, then converts to float32")
print("2. All element matrix computations are in float32")
print("3. All matrix assembly operations are in float32")
print("4. Final K and M matrices are stored as float32 sparse matrices")
print("5. This matches MATLAB's default behavior (single precision = float32)")

print("\nPrecision comparison with MATLAB:")
print("  MATLAB: Uses 'single' precision (float32) by default in sparse matrices")
print("  Python: Uses float32 throughout the computation chain")
print("  → Both use the same precision (float32)")

